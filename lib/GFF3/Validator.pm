package GFF3::Validator;

=head1 NAME

GFF3::Validator

=head1 SYNOPSIS

 # Create validator object
 my $validator = GFF3::Validator->new(-config         => $config,
                                      -gff3_file      => $gff3_file,
                                      -datasource     => $datasource,
                                      -username       => $username,
                                      -password       => $password,
                                      -verbose        => $verbose,
                                      -silent         => $silent,
                                      -max_messages     => $max_messages,
                                      -log_file       => $log_file,
                                      -report_file    => $report_file,
                                      -ontology_files => \@ontology_files,
                                      );

 # Create/Reset tables to store the data
 $validator->create_tables;

 # Load gff3 analysis database
 $validator->load_analysis_dbs;

 # Validate unique ids
 $validator->validate_unique_ids;

 # Load ontology(s) into memory
 $validator->load_ontology;

 # Validate ontology terms
 $validator->validate_ontology_terms;

 # Validate parentage
 $validator->validate_parentage;

 # Validate derives_from
 $validator->validate_derives_from;

 # Dump an error report
 $validator->dump_report;

=head1 DESCRIPTION

GFF3 Validation module.

=cut

=head1 USAGE

This module is not used directly. Please see documentation for validate_gff3.pl for usage.

=cut

use strict;
use DBI;
use Carp;
use GO::Parser;
use Time::Format qw(%time);
use Config::General;
use Data::Dumper;
use Digest::SHA1;
use LWP;
use File::Temp;
use List::Util;
#DBI->trace(0);

=head1 METHODS

=head2 Constructor

=head3 new

The following parameters can be provided to the constructor:

 Parameter        Description                                             Default
 ---------        -----------                                             -------
 -config          Config file                                             n/a
 -gff3_file       GFF3 file                                               n/a
 -datasource      DBI datasource for the database to be used              n/a
                  for loading data
 -username        Datasource username                                     ""
 -password        Datasource password                                     ""
 -verbose         Logging verbosity                                       2
                  1: Initialization information
                  2: + Progress information
                  3: + Error messages
 -silent          Whether to suppress logging to screen                   0
                  0: Log to screen
                  1: Don't log to screen
 -max_messages    0: Report all messages                                  0
                  <number>: Exit and report after <number> messages         
 -log_file        Log file                                                ""
 -report_file     Report file                                             ""
 -ontology_files  Hashref to external ontology files                      ()
 -table_id        Table id                                                <auto-generated>

=cut

sub new {
    my ($class, %params) = @_;

    # Create and bless object
    my %obj = {};
    my $self = bless \%obj, $class;

    # First read config file, parse and store it
    my $config = $params{-config} or croak("A config must be specified!");
    my $config_obj = Config::General->new(-ConfigFile => $config, -CComments => 0);
    my %config = $config_obj->getall;
    $self->{config} = \%config;

    # Assign values, constructor args override config file args
    my $gff3_file       = $params{-gff3_file}  || croak("A gff3_file must be specified!");
    my $datasource      = $params{-datasource} || $self->config("datasource") || croak("A datasource must be specified!");
    my $username        = $params{-username}   || $self->config("username")   ||  "";
    my $password        = $params{-password}   || $self->config("password")   ||  "";

    my $verbose         = (defined $params{-verbose}     && $params{-verbose}     ne "") ? $params{-verbose}     : 2;
    my $silent          = (defined $params{-silent}      && $params{-silent}      ne "") ? $params{-silent}      : 0;
    my $log_file        = (defined $params{-log_file}    && $params{-log_file}    ne "") ? $params{-log_file}    : "";
    my $report_file     = (defined $params{-report_file} && $params{-report_file} ne "") ? $params{-report_file} : "";

    my $max_messages    = (defined $params{-max_messages}  && $params{-max_messages}  ne "") ? $params{-max_messages}  + 0 : 0;

    my @ontology_files  = defined $params{-ontology_files} ? @{$params{-ontology_files}} : ();

    my $table_id        = defined $params{-table_id} ? $params{-table_id} : undef;

    # Store gff3 file
    $self->gff3_file($gff3_file);

    # Store verbosity
    $self->verbose($verbose);

    # Store silent
    $self->silent($silent);
    
    # Store max_messages
    $self->max_messages($max_messages);

    # Reset log file, store log_file name
    if ($log_file and $verbose > 0) {
        open (LOG_FILE, ">$log_file") or croak("Cannot write log file ($log_file):$!");
        $self->log_file($log_file);

        #Initialize log file
        $self->log("# GFF3::Validator Log File");
        $self->log("# ");
        $self->log("# gff3_file:                     $gff3_file");
        $self->log("# command-line ontology_file(s): " . join(",", @ontology_files));
        $self->log("# log_file:                      $log_file");
        $self->log("# report_file:                   $report_file");
        $self->log("# datasource:                    $datasource");
        $self->log("");
        }

    # Store report file
    $self->report_file($report_file);

    # Unset currently_in_fasta
    $self->currently_in_fasta(0);

    # Create ontology files hash and populate with ones provided to the constructor
    $self->{ontology_files} = {};
    foreach my $ontology_file (@ontology_files) {
        $self->ontology_files("command-line", $ontology_file);
        }

    # Store default ontology file
    my $default_sofa_url = $self->config("default_sofa_url");
    $self->ontology_files("default", $default_sofa_url);

    # Store/generate table_id
    $self->table_id($table_id);

    # Connect to database and store db handle
    my $dbh = DBI->connect($datasource, $username, $password)
        or croak($DBI::errstr);
    $dbh->{RaiseError} = 1;
    $dbh->{PrintError} = 1;
    $self->dbh($dbh);
    
    # Set db_type
    if ($datasource =~ /SQLite/i) {
        $self->db_type('sqlite');
        my $sqlite_cache_size = $self->config("sqlite_cache_size") || 512000;
        $self->dbh($dbh)->do("PRAGMA cache_size = $sqlite_cache_size");
        $self->dbh($dbh)->do("PRAGMA synchronous = OFF");
        }
    else {
        $self->db_type('mysql'); # Currently all non-SQLite 
        }

    # Pre-set complete_parse
    $self->complete_parse(1);
    
    return $self;
    }

=head2 Get/Set Methods

=head3 config

 Function  : Gets config value
 Arguments : $key
 Returns   : $value
 Notes     :

=cut

sub config {
  my ($self, $key) = @_;

  croak("Unknown config key ($key)!") unless exists $self->{config}->{$key};

#   if( $key eq 'temp_dir') {
#     my $temp_dir = $self->{config}->{$key};
#     #append our username to the temp dir, to avoid problems when multiple users run this
#     my $username = getpwuid($<);
#     $temp_dir =~ s|/$||;
#     $temp_dir .= ".$username/";
#     mkdir $temp_dir;
#     return $temp_dir;
#   }
  return $self->{config}->{$key};
}

=head3 ontology_files

 Function  : Adds an ontology file to the list of ontology files,
             returns non-redundant list of ontology_files
             and their locations as an hashref
 Arguments : ($type, $ontology_file) | None
 Returns   : 1 | \%valid_ontology_files
 Notes     :

=cut

sub ontology_files {
	my ($self, $type, $ontology_file) = @_;

    if ($type) {

        if ($type ne "directive"    and
            $type ne "command-line" and
            $type ne "default"         ) {
                croak("Invalid ontology file type ($type)!");
                }

        croak("An ontology file is required!") unless $ontology_file;

        $self->{ontology_files}->{$type}->{$ontology_file} = 1;

        return 1;
        }

    else {
#         my %valid_ontology_files;
#         my %retrieved_ontology_files;

        foreach my $type ("command-line", "directive", "default") {
            my $ref_ontology_files = $self->{ontology_files}->{$type};

            if ($type eq "default" and scalar(keys %{$self->{valid_ontology_files}})) {
                next;
                }

            foreach my $ontology_file (keys %{$ref_ontology_files}) {
	      $self->{retrieved_ontology_files}->{$ontology_file};
                # next if $valid_ontology_files{$ontology_file};
                # next if $retrieved_ontology_files{$ontology_file};

                my $retrieved_file = $self->_retrieve_file($ontology_file);

                $self->{valid_ontology_files}->{$ontology_file} = $retrieved_file if $retrieved_file;
                # $valid_ontology_files{$ontology_file} = $retrieved_file if $retrieved_file;
                $self->{retrieved_ontology_files}->{$ontology_file} = 1;
                # $retrieved_ontology_files{$ontology_file} = 1;
                }
            }

        return $self->{valid_ontology_files} ? $self->{valid_ontology_files} : {}; # \%valid_ontology_files;
        }
	}

=head3 table_id

 Function  : Gets/setd table id to be used as prefix for tables
             If not available generated automatically
 Arguments : ($table_id) | None
 Returns   : $table_id
 Notes     :

=cut

sub table_id {
	my ($self, $value) = @_;

    my $temp_dir = $self->config("temp_dir");

    my $time_stamp = qq[Accessed: ] . $time{"dd-Mon-yy hh:mm:ss"} . "\n";

    if (defined $value) {
        $self->{table_id} = $value;
        open (TABLE_LOCK, ">>$temp_dir/$value.table_lock") or croak("Cannot create table lock for table id ($value): $!");
        print TABLE_LOCK  $time_stamp;
        close TABLE_LOCK;
        }

    if (!defined $self->{table_id}) {
        my ($temp_fh, $temp_file) = File::Temp::tempfile("XXXX",
                                                         DIR     => $temp_dir,
                                                         SUFFIX  => '.table_lock',
                                                         );
        print $temp_fh $time_stamp;
        my ($table_id) = $temp_file =~ /(.{4})\.table_lock$/;
        $table_id = $table_id . qq[_]; # *** Note the underscore in table id ***
        $self->{table_id} = $table_id;
        }

    return $self->{table_id};
    }

=head3 gff3_file

 Function  : Gets/Sets gff3 file
 Arguments : $gff3_file | None
 Returns   : $gff3_file
 Notes     :

=cut

sub gff3_file {
	my ($self, $value) = @_;

    if (defined $value) {
        $self->{gff3_file} = $value;
        }

    return $self->{gff3_file};
	}

=head3 dbh

 Function  : Gets/Sets database handle
 Arguments : $dbh | None
 Returns   : $dbh
 Notes     :

=cut

sub dbh {
	my ($self, $value) = @_;

    if (defined $value) {
        $self->{dbh} = $value;
        }

    return $self->{dbh};
	}

=head3 db_type

 Function  : Gets/Sets database type
 Arguments : $db_type <mysql | sqlite> | None 
 Returns   : $db_type
 Notes     :

=cut

sub db_type {
	my ($self, $value) = @_;

    if (defined $value) {
        $self->{db_type} = $value;
        }

    return $self->{db_type};
	}

=head3 verbose

 Function  : Gets/Sets verbosity
 Arguments : $verbose | None
 Returns   : $verbose
 Notes     :

=cut

sub verbose {
	my ($self, $value) = @_;

    if (defined $value) {
        $self->{verbose} = $value;
        }
    return $self->{verbose};
	}

=head3 silent

 Function  : Gets/Sets silent variable
 Arguments : $silent | None
 Returns   : $silent
 Notes     :

=cut

sub silent {
	my ($self, $value) = @_;

    if (defined $value) {
        $self->{silent} = $value;
        }
    return $self->{silent};
	}

=head3 max_messages

 Function  : Gets/Sets max_messages variable
 Arguments : $max_messages | None
 Returns   : $max_messages
 Notes     :

=cut

sub max_messages {
	my ($self, $value) = @_;

    if (defined $value) {
        $self->{max_messages} = $value;
        }
    return $self->{max_messages};
	}

=head3 complete_parse

 Function  : Gets/Sets complete_parse tracking variable
 Arguments : $complete_parse | None
 Returns   : $complete_parse
 Notes     :

=cut

sub complete_parse {
	my ($self, $value) = @_;

    if (defined $value) {
        $self->{complete_parse} = $value;
        }

    return $self->{complete_parse};
	}

=head3 currently_in_fasta

 Function  : Gets/Sets currently_in_fasta tracking variable
 Arguments : $currently_in_fasta | None
 Returns   : $currently_in_fasta
 Notes     :

=cut

sub currently_in_fasta {
	my ($self, $value) = @_;

    if (defined $value) {
        $self->{currently_in_fasta} = $value;
        }

    return $self->{currently_in_fasta};
	}

=head3 log_file

 Function  : Gets/Sets name of log file
 Arguments : $log_file | None
 Returns   : $log_file
 Notes     :

=cut

sub log_file {
	my ($self, $value) = @_;

    if (defined $value) {
        $self->{log_file} = $value;
        }

    return $self->{log_file};
	}

=head3 report_file

 Function  : Gets/Sets name of report file
 Arguments : $report_file | None
 Returns   : $report_file
 Notes     :

=cut

sub report_file {
	my ($self, $value) = @_;

    if (defined $value) {
        $self->{report_file} = $value;
        }

    return $self->{report_file};
	}

=head3 error_count

 Function  : Gets/Sets error_count
 Arguments : $number
 Returns   : $error_count
 Notes     :

=cut

sub error_count {
	my ($self, $value) = @_;

    if (defined $value) {
        $self->{error_count} = $value;
        }

    return $self->{error_count};
	}

=head3 warning_count

 Function  : Gets/Sets warning_count
 Arguments : $number
 Returns   : $warning_count
 Notes     :

=cut

sub warning_count {
	my ($self, $value) = @_;

    if (defined $value) {
        $self->{warning_count} = $value;
        }

    return $self->{warning_count};
	}

=head3 message_count

 Function  : Gets/Sets message_count
 Arguments : $number
 Returns   : $message_count
 Notes     :

=cut

sub message_count {
	my ($self, $value) = @_;

    if (defined $value) {
        $self->{message_count} = $value;
        }

    return $self->{message_count};
	}

=head3 graph

 Function  : Gets/Sets for GO graph
 Arguments : $graph | None
 Returns   : $graph
 Notes     :

=cut

sub graph {
    my ($self, $value) = @_;

    if (defined $value) {
        $self->{graph} = $value;
        }

    return $self->{graph};
    }

=head3 terms_by_both

 Function  : Gets/Sets hash of terms (by acc and name)
 Arguments : $hash | None
 Returns   : $hashref
 Notes     :

=cut

sub terms_by_both {
    my ($self, $value) = @_;

    if (defined $value) {
        $self->{terms_by_both} = $value;
        }

    return $self->{terms_by_both};
    }

=head3 parents_of_by_both

 Function  : Gets/Sets hash of parents_of (by acc and name) relationships
 Arguments : None/$value
 Returns   : $hashref
 Notes     :

=cut

sub parents_of_by_both {
    my ($self, $value) = @_;

    if (defined $value) {
        $self->{parents_of_by_both} = $value;
        }

    return $self->{parents_of_by_both};
    }

=head3 derives_from_by_both

 Function  : Gets/Sets hash of derives_from (by acc and name) relationships
 Arguments : None/$value
 Returns   : $hashref
 Notes     :

=cut

sub derives_from_by_both {
    my ($self, $value) = @_;

    if (defined $value) {
        $self->{derives_from_by_both} = $value;
        }

    return $self->{derives_from_by_both};
    }

=head3 get_sth

 Function  : Gets stored statement handles by alias
 Arguments : $alias
 Returns   : $sth
 Notes     :

=cut

sub get_sth {
	my ($self, $alias) = @_;

    my $dbh     = $self->dbh;
    my $db_type = $self->db_type;
        
    my $sth;
    
    # In SQLite, stored sths cause database schema has changed error,
    # sth is prepared and sent back for these cases
    if ($db_type eq 'sqlite') {
        if (!$self->{statements}->{$alias}) {
            croak("Unknown statements alias ($alias)!");
            }
        $sth = $dbh->prepare($self->{statements}->{$alias});
        }
    
    else { 
        if (!$self->{sths}->{$alias}) {
            croak("Unknown sth alias ($alias)!");
            }
        $sth = $self->{sths}->{$alias};
        }
        
    return $sth;
	}

=head3 stop_parse

 Function  : Determines whether to stop_parse or continue
 Arguments : None
 Returns   : 0 | 1
 Notes     :

=cut

sub stop_parse {
    my ($self) = @_;
    my $stop_parse = 0;
    
    if ($self->max_messages && $self->message_count >= $self->max_messages) {
            $self->log("max message count reached, stopping parsing");
            $self->complete_parse(0);
            $stop_parse = 1;
            }
    return $stop_parse;
    }    

=head2 Analysis Methods

=head3 create_tables

 Function  : Creates tables for storing analysis data
 Arguments : None
 Returns   : 1
 Notes     :

=cut

sub create_tables  {
	my ($self) = @_;

    my $dbh = $self->dbh;

    my $table_id = $self->table_id;

    my $db_type = $self->db_type;
    
    $self->log("Creating/resetting tables ...");
    $self->log;

    my $auto_increment = $db_type eq 'mysql' ? 'AUTO_INCREMENT' : 'AUTOINCREMENT';
    
    my @create_statements = (
        qq[DROP TABLE IF EXISTS ${table_id}byte_offset],
        qq[CREATE TABLE ${table_id}byte_offset (
           byte_offset_id  integer PRIMARY KEY $auto_increment,
           line_number     int(11) NOT NULL,
           byte_offset     int(11)
           )
           ],
        qq[DROP TABLE IF EXISTS ${table_id}feature],
        qq[CREATE TABLE ${table_id}feature (
           feature_id   integer PRIMARY KEY $auto_increment,
           line_number  int(11) NOT NULL,
           source       varchar(255),
           type         varchar(255),
           id           varchar(255),
           digest       char(40),
           valid_source char(1),                    -- Y(es) or N(o)
           valid_type   char(1),                    -- Y(es) or N(o)
           unique_id    char(1)                     -- Y(es) or N(o)
           )
           ],
        qq[DROP TABLE IF EXISTS ${table_id}directive],
        qq[CREATE TABLE ${table_id}directive (
           directive_id    integer PRIMARY KEY $auto_increment,
           line_number     int(11) NOT NULL,
           directive       varchar(255)
           )
           ],
        qq[DROP TABLE IF EXISTS ${table_id}parent],
        qq[CREATE TABLE ${table_id}parent (
           parent_id    integer PRIMARY KEY $auto_increment,
           line_number  int(11) NOT NULL,
           parent       varchar(255),
           valid_link   char(1)                    -- Y(es) or N(o)
           )
           ],
        qq[DROP TABLE IF EXISTS ${table_id}derives_from],
        qq[CREATE TABLE ${table_id}derives_from (
           derives_from_id integer PRIMARY KEY $auto_increment,
           line_number     int(11) NOT NULL,
           derives_from    varchar(255),
           valid_link      char(1)                 -- Y(es) or N(o)
           )
           ],
        qq[DROP TABLE IF EXISTS ${table_id}message],
        qq[CREATE TABLE ${table_id}message (
           message_id     integer PRIMARY KEY $auto_increment,
           line_number    int(11) NOT NULL,
           type           char(1) NOT NULL,        -- E(rror) or W(arning)
           message        varchar(255),
           details        varchar(255)
           )
           ],
        );

    foreach my $create_statement (@create_statements) {
        $dbh->do($create_statement);
        }

    $self->log("Created/reset tables");

    # Prepare statement handles
    my $sths = $self->_prepare_sths;

    $self->log_ok;

    return 1;
    }

=head3 cleanup

 Function  : Cleans tables and lock file
 Arguments : None
 Returns   : 1
 Notes     :

=cut

sub cleanup  {
	my ($self) = @_;

    my $dbh = $self->dbh;

    my $temp_dir = $self->config("temp_dir");
    my $table_id = $self->table_id;

    $self->log("Cleaning tables and lock file ...");
    $self->log;

    my @drop_statements = (
        qq[DROP TABLE IF EXISTS ${table_id}byte_offset],
        qq[DROP TABLE IF EXISTS ${table_id}feature],
        qq[DROP TABLE IF EXISTS ${table_id}directive],
        qq[DROP TABLE IF EXISTS ${table_id}parent],
        qq[DROP TABLE IF EXISTS ${table_id}derives_from],
        qq[DROP TABLE IF EXISTS ${table_id}message],
        );

    foreach my $drop_statement (@drop_statements) {
        $dbh->do($drop_statement);
        }

    my ($truncated_table_id) = $table_id =~ /^([^\_]+)/;
    my $lock_file = "$temp_dir/$truncated_table_id.table_lock";
    unlink ($lock_file) or croak("Cannot unlink table lock file ($lock_file)!");

    $self->log("Tables and lock file removed");
    $self->log_ok;

    return 1;
    }

=head3 load_analysis_dbs

 Function  : Parses GFF3 file and loads into analysis databases
 Arguments : None
 Returns   : 1
 Notes     :

=cut

sub load_analysis_dbs {
    my ($self) = @_;

    my $file = $self->gff3_file;
    my $dbh = $self->dbh;

    my $table_id = $self->table_id;

    $self->log("Loading analysis databases ...");
    $self->log;

    # Stop parse if max count reached
    if ($self->stop_parse) {
        return 1;
        }

    # Drop indexes
    $self->_manage_indexes("drop", qw[idx_byte_offset_line_number
                                      idx_byte_offset_byte_offset

                                      idx_feature_line_number
                                      idx_feature_source
                                      idx_feature_type
                                      idx_feature_id
                                      idx_feature_digest

                                      idx_directive_line_number
                                      idx_directive_directive

                                      idx_parent_line_number
                                      idx_parent_parent

                                      idx_derives_from_line_number
                                      idx_derives_from_derives_from
                                      ]);
    $self->log;

    # Prepare statement handles
    my %statement_templates = (
                                insert_byte_offset  => qq[INSERT INTO ${table_id}byte_offset
                                                          (line_number, byte_offset)
                                                          VALUES],

                                insert_feature      => qq[INSERT INTO ${table_id}feature
                                                          (line_number, source, type, id, digest)
                                                          VALUES],

                                insert_directive    => qq[INSERT INTO ${table_id}directive
                                                          (line_number, directive)
                                                          VALUES],

                                insert_parent       => qq[INSERT INTO ${table_id}parent
                                                          (line_number, parent)
                                                          VALUES],

                                insert_derives_from => qq[INSERT INTO ${table_id}derives_from
                                                          (line_number, derives_from)
                                                          VALUES],
                                );

    open (IN, "<$file") or croak("Cannot read file ($file): $!");

    my $line_number = 0;

    # Go through each line, parse, check for fatal errors,
    # load into the database
    $self->log("Going through gff3 file ...");
    $self->log;

    while (my $line = <IN>) {
        # Stop parse if max count reached
        if ($self->stop_parse) {
            last;
            }

        chomp $line;
        $line =~ s/\r$//;

        if (${line_number}%$self->config("line_number_chunk") == 1) {
            $self->log("loaded line_number $line_number");
            }

        # Count line number
        $line_number++;

        # Record byte_offset information
        my $byte_offset = tell IN;

        # Record byte_offset in the database
        $self->_buffer_and_load($statement_templates{insert_byte_offset}, [$line_number, $byte_offset]);

        # Parse and validate line
        my ($line_type, $ref_parsed_data, $ref_additional_information) = $self->_validate_line($line_number, $line);

        # Foreach type of line, process it and load to db

        # Special case, 1st line must be ##gff-version 3
        if ($line_number == 1 && $ref_parsed_data->[0] ne '##gff-version 3') {
            $self->message($line_number, 'E', "first line must be ##gff-version 3", "line: " . $ref_parsed_data->[0]);
            }

        # Type: feature
        if ($line_type eq 'feature') {
            $self->_buffer_and_load($statement_templates{insert_feature}, [$line_number, @$ref_parsed_data]);

            # Retrieve parse out parent and derives from information, store in the database
            my @parents = @{$ref_additional_information->{Parent}};
            my @derives_froms = @{$ref_additional_information->{Derives_from}};

            foreach my $parent (@parents) {
                $self->_buffer_and_load($statement_templates{insert_parent}, [$line_number, $parent]);
                }
            foreach my $derives_from (@derives_froms) {
                $self->_buffer_and_load($statement_templates{insert_derives_from}, [$line_number, $derives_from]);
                }
            }

        # Type: feature
        elsif ($line_type eq 'directive') {
            $self->_buffer_and_load($statement_templates{insert_directive}, [$line_number, @$ref_parsed_data]);
            }

        # Type: other
        elsif ($line_type eq 'other') {
            # Do nothing
            }

        # Type: (else)
        else {
            croak("Invalid line type ($line_type)!");
            }
        }

    # Flush all data load buffer
    $self->_buffer_and_load("flush_all");

    # Close gff3 file
    close IN or croak("Cannot close gff3 file ($file): $!");

    # Completed going through gff3 file
    $self->log;
    $self->log("Completed going through gff3");
    $self->log_ok;

    # Create indexes
    $self->_manage_indexes("create", qw[idx_feature_line_number
                                      idx_feature_type
                                      idx_feature_id
                                      idx_parent_line_number
                                      idx_parent_parent
                                      idx_derives_from_line_number
                                      idx_derives_from_derives_from]);
    $self->log;

    $self->log("Loading complete, processed $line_number lines");
    $self->log_ok;

    return 1;
    } # End of loading method

=head4 _buffer_and_load

 Function  : Buffers and loads data
 Arguments : $statement_template, \@data
 Returns   : 1
 Notes     : This is a private method

=cut

sub _buffer_and_load {
	my ($self, $statement_template, $ref_data) = @_;

    my $dbh = $self->dbh;
    my $max_buffer_size = $self->config("max_buffer_size");

    my $data_store = $self->{data_store};

    # SQLite does not support specifying multiple value sets in a single INSERT statement
    # These type of inserts are executed as they are received and sub returns
    if ($self->db_type eq 'sqlite' and $statement_template ne "flush_all") {
        my $data_string = $self->_construct_data_string([$ref_data]); # This will always be a single ary ref
        my $statement = $statement_template . qq[ ] . $data_string;
        $dbh->do($statement);
        
        return 1;
        }

    if ($statement_template eq "flush_all") {
        if ($ref_data) { croak("(_buffer_and_load: you cannot provide data when flush_all is specified!"); }

        foreach my $stored_statement_template (keys %$data_store) {
            my $ref_stored_data = $data_store->{$stored_statement_template};
            if (@{$ref_stored_data} >= 1) {
                my $data_string = $self->_construct_data_string($ref_stored_data);
                my $statement = $stored_statement_template . qq[ ] . $data_string;
                $dbh->do($statement);
                $data_store->{$stored_statement_template} = [];
                }
            }
        }

    else {
        push @{$data_store->{$statement_template}}, $ref_data;
        my $ref_stored_data = $data_store->{$statement_template};

        if (@{$ref_stored_data} >= $max_buffer_size) {
            my $data_string = $self->_construct_data_string($ref_stored_data);
            my $statement = $statement_template . qq[ ] . $data_string;
            $dbh->do($statement);
            $data_store->{$statement_template} = [];
            }
        }

    $self->{data_store} = $data_store;

    return 1;
    }

=head4 _construct_data_string

 Function  : Constructs a data string to be used in _buffer_and_load
 Arguments : \@data
 Returns   : $data_string
 Notes     : This is a private method

=cut

sub _construct_data_string {
	my ($self, $ref_data) = @_;

    my $dbh = $self->dbh;

    my @data_string;
    foreach my $ref_data_segment (@$ref_data) {
        my @quoted_data_segment = map { (defined $_ && $_ ne "") ? $dbh->quote($_) : "NULL" } @$ref_data_segment;
        push (@data_string, qq[(] . join(", ", @quoted_data_segment) . qq[)]);
        }

    my $data_string = join(", ", @data_string);

    return $data_string;
    }

=head4 _validate_line

 Function  : Validates a gff3 line
 Arguments : $line_number, $line
 Returns   : $line_type, \@parsed_data
 Notes     : This is a private method

=cut

sub _validate_line {
	my ($self, $line_number, $line) = @_;

    # At the end of validation, these variables will be returned
    my $line_type;
    my @parsed_data;
    my %additional_information;

    # Allowing spaces at the end of lines
    $line =~ s/ +$//;

    # IMPORTANT: There are 3 types of lines:
    #
    # 1) "other"     these are not used in any calculations, they are not recorded
    # 2) "directive" these can have file-wide analysis effects, they are recorded for later use
    #                if their format is incorrect, they are skipped, not loaded into the database and they do *not* affect later analysis
    # 3) "feature"   main information lines, these are heavily checked, each part is processed separately
    #                generally, if a part is malformed, it does not get loaded into the database
    #                however, there are some parts that are loaded into the database even if they are malformed/invalid
    #                e.g. a malformed seqid is loaded, a malformed start position is not loaded

    #########################
    # LINE TYPE 1 - "other" #
    #########################

    # If this is an empty line, just record it
    if ($line eq "") {
        $line_type = 'other';
        @parsed_data = ('placeholder');
        %additional_information = ();
        }

    # If we have previously encountered a ##FASTA directive, just record it
    elsif ($self->currently_in_fasta) {
        $line_type = 'other';
        @parsed_data = ('placeholder');
        %additional_information = ();
        }

    # If this is a comment, just record it
    elsif ($line =~ /^#[^#]/ or $line eq "#") {
        $line_type = 'other';
        @parsed_data = ('placeholder');
        %additional_information = ();
        }

    # If this is a line starting with '>', set $self->currently_in_fasta (for backward compatibility)
    elsif ($line =~ /^>/) {
        $self->currently_in_fasta(1);

        $line_type = 'other';
        @parsed_data = ('placeholder');
        %additional_information = ();
        }

    #############################
    # LINE TYPE 2 - "directive" #
    #############################

    # If this is a directive, validate it
    elsif ($line =~ /^##/) {

        # Allowing multiple spaces
        $line =~ s/ +/ /g;

        # If a directive is invalid/malformed, it is not stored in the database
        # following variable is used to track errors
        my $valid_directive = 1;

        if ($line =~ /^##gff-version/) {
            if ($line eq '##gff-version 3') {
                # Do nothing
                }
            else {
                $self->message($line_number, 'E', "invalid directive", "directive: $line");
                $valid_directive = 0;
                }
            if ($line_number != 1) {
                $self->message($line_number, 'E', "##gff-version directive is not the first line", "directive: $line, line_number: $line_number");
                $valid_directive = 0;
                }
            }

        elsif ($line =~ /^##sequence-region/) {
            if ($line =~ /^##sequence-region \S+ \d+ \d+/) {
                # Do nothing
                }
            else {
                $self->message($line_number, 'E', "malformed directive", "directive: $line");
                $valid_directive = 0;
                }
            }

        elsif ($line =~ /^##feature-ontology/) {
            if ($line =~ /^##feature-ontology (\S+)$/) {
                $self->ontology_files("directive", $1);
                }
            else {
                $self->message($line_number, 'E', "malformed directive", "directive: $line");
                $valid_directive = 0;
                }
            }

        elsif ($line =~ /^##attribute-ontology/) {
            if ($line =~ /^##attribute-ontology \S+$/) {
                $self->message($line_number, 'E', "directive reserved for future use", "directive: $line");
                $valid_directive = 0;
                }
            else {
                $self->message($line_number, 'E', "malformed directive", "directive: $line");
                $valid_directive = 0;
                }
            }

        elsif ($line =~ /^##source-ontology/) {
            if ($line =~ /^##source-ontology \S+$/) {
                $self->message($line_number, 'E', "directive reserved for future use", "directive: $line");
                $valid_directive = 0;
                }
            else {
                $self->message($line_number, 'E', "malformed directive", "directive: $line");
                $valid_directive = 0;
                }
            }

        elsif ($line =~ /^###/) {
            if ($line eq '###') {
                # Do nothing
                }
            else {
                $self->message($line_number, 'E', "malformed directive", "directive: $line");
                $valid_directive = 0;
                }
            }

        elsif ($line =~ /^##FASTA/) {
            if ($line eq '##FASTA') {
                $self->currently_in_fasta(1);
                $self->log("Now in FASTA sequence segment");
                }
            else {
                $self->message($line_number, 'E', "malformed directive", "directive: $line");
                $valid_directive = 0;
                }
            }

        elsif ($line =~ /^##Index-subfeatures/) {
            if ($line =~ /^##Index-subfeatures\s+(0|1)\s*$/) {
                # Do nothing
                }
            else {
                $self->message($line_number, 'E', "malformed directive", "directive: $line");
                $valid_directive = 0;
                }
            }

        else {
            $self->message($line_number, 'W', "unknown directive", "directive: $line");
            $valid_directive = 0;
            }

        # If there are no errors, schedule this directive for storage
        $line_type = 'directive';
        @parsed_data = $valid_directive ? ($line) : (undef);
        %additional_information = ();

        # End of processing of directives
        }

    #############################
    # LINE TYPE 3 - "feature"   #
    #############################

    # If it doesn't match any of these, it will be treated as a feature line
    else {
        my %feature_errors; # variable to track errors
                            # (each part of a feature is processed separately)

        my %feature_attributes; # variable to track
                                # attributes of a feature

        my %valid_feature_attributes; # variable to track
                                      # valid attributes of a feature

        # Parse line
        my @fields = split("\t", $line);
        if (@fields != 9) {
           $self->message($line_number, 'E', "incorrect number of fields", "fields: " . @fields);
           }

        # Empty fields must have a dot
        foreach my $i (0..$#fields) {
            if ((!defined $fields[$i]) or $fields[$i] eq "") {
                $self->message($line_number, 'E', "empty field", "field: " . $i);
                }
            }

        #################################
        # The fields are processed here #
        #################################

        # Assign fields
        my ($seqid, $source, $type, $start, $end, $score, $strand, $phase, $attributes) = @fields;

        # Validate seqid
        if ($seqid =~ /[^a-zA-Z0-9\.\:\^\*\$\@\!\+\_\?\-\|\%]/) {
            $self->message($line_number, 'E', "illegal character in field", "seqid: $seqid");
            }
        if ($seqid eq '.') {
            $self->message($line_number, 'E', "feature does not have a seqid specified", undef);
            }

        # Validate source
        if ($source =~ /[^a-zA-Z0-9\.\: \^\*\$\@\!\+\_\?\-\%]/) {
            $self->message($line_number, 'E', "illegal character in field", "source: $source");
            }

        # Validate type
        if ($type =~ /[^a-zA-Z0-9\.\: \^\*\$\@\!\+\_\?\-]/) {
            $self->message($line_number, 'E', "illegal character in field", "type: $type");
            }
        if ($type eq '.') {
            $self->message($line_number, 'E', "feature does not have a type specified", undef);
            }

        # Validate start and end
        if ($start =~ /[^\d]/ or $end =~ /[^\d]/) {
            $self->message($line_number, 'E', "illegal character in field", "start: $start, end: $end");
            }
        if ($start < 1 or $end < 1) {
            $self->message($line_number, 'E', "start and/or end is not in 1-based coordinate system", "start: $start, end: $end");
            }
        if ($end < $start) {
            $self->message($line_number, 'E', "end is not greater than or equal to start", "start: $start, end: $end");
            }

        # Validate score
        if ($score ne "."                              and
            $score !~ /^[\+\-]{0,1}\d+\.\d+$/          and
            $score !~ /^[\+\-]{0,1}\d+$/               and
            $score !~ /^[\+\-]{0,1}\d+(e|E)[\+\-]\d+$/ and
            $score !~ /^[\+\-]{0,1}\d+\.\d+(e|E)[\+\-]\d+$/            
            ) {
            $self->message($line_number, 'E', "illegal character in field", "score: $score");
            }

        # Validate strand
        if ($strand !~ /^[\+\-\.]$/) {
            $self->message($line_number, 'E', "illegal character in field", "strand: $strand");
            }

        # Validate phase
        if ($phase !~ /^[012\.]$/) {
            $self->message($line_number, 'E', "illegal character in field", "phase: $phase");
            }

        # Validate phase for CDS
        if ($type eq 'CDS' and $phase !~ /^[012]$/) {
            $self->message($line_number, 'E', "CDS does not have a phase", "phase: $phase");
            }

        ##########################################
        # The attributes field is processed here #
        ##########################################

        # Validate attributes; Remember: [; = , tab] must be escaped. However, cleaning is not necessary for only comparison purposes
        if ($attributes eq '.') {
            # Do nothing
            }

        else {
            if ($attributes =~ /[;\s]+$/) {
                $self->message($line_number, 'E', "empty tag/value information", "$attributes");
                $attributes =~ s/[;\s]+$//;
                }
                                   
            foreach my $attribute (split(";", "$attributes")) {
                if (!defined $attribute or $attribute eq "" or $attribute =~ /^\s+$/) {
                    $self->message($line_number, 'E', "empty attribute", "$attribute");
                    }
                    
                my ($tag, $values) = $attribute =~ /^([^=]+)=(.*)/;  # We call it values as it might
                                                                     # contain multiple values separated with comma

                # Check empty tag/value
                if (!defined $tag or !defined $values) {
                    $self->message($line_number, 'E', "attribute not in tag=value format", "$attribute");
                    }
                else {
                    my @values = split(',', "$values,placeholder"); pop @values; # Make sure last item is included
                    foreach my $value (@values) {
                        if (!defined $value or $value eq "" or $value =~ /^\s+$/) {
                            $self->message($line_number, 'E', "empty tag value/malformed tag-value pair", "$attribute");
                            }
                        }
                    }

                # Check if this tag appears more than once
                if (exists $feature_attributes{$tag}) {
                    $self->message($line_number, $self->config("same_multiple_tags"), "feature has multiple tags of the same type", "tag: $tag");
                    }

                # Check value
                if ($values =~ /=/) {
                    $self->message($line_number, 'E', "tag value contains an equals sign", "$tag=$values");
                    }

                # Check tag
                $self->message($line_number, 'E', "empty tag name", "tag: $tag") if (defined $tag && $tag eq "");
                $self->message($line_number, 'E', "empty tag name", "tag: $tag") if $tag =~ /^\s+$/;
                $self->message($line_number, 'E', "tag has preceding space", "tag: $tag") if $tag =~ /^\s+/;
                $self->message($line_number, 'E', "tag has leading space", "tag: $tag")   if $tag =~ /\s+$/;

                # Check if this is an first-uppercase tag (if so it's reserved and check contents)
                if ($tag =~ /^[A-Z]/) {

                    # Process multiple values
                    foreach my $value (split ",", $values) {

                        my $valid_value = 1; # Variable to track validity of value

                        # Check if non-empty value
                        if (!(defined $values) or $value eq "" or $value =~ /^ +$/) {
                            $self->message($line_number, 'E', "empty tag value", "$tag: $value");
                            $valid_value = 0;
                            }

                        # Validate Name
                        if ($tag eq 'ID') {
                            # Don't do anything
                            }

                        elsif ($tag eq 'Name') {
                            # Don't do anything
                            }

                        elsif ($tag eq 'Alias') {
                            # Don't do anything
                            }

                        elsif ($tag eq 'Parent') {
                            # Don't do anything
                            }

                        elsif ($tag eq 'Target') {
                            if ($value !~ /^\S+\s+\d+\s+\d+$/ and
                                $value !~ /^\S+\s+\d+\s+\d+\s+[\+\-]/) {
                                $self->message($line_number, 'E', "invalid reserved attribute format", "$tag: $value");
                                $valid_value = 0;
                                }
                            }

                        elsif ($tag eq 'Gap') {
                            my $malformed = 0;
                            foreach my $operation (split /\s+/, $value) {
                                if ($operation !~ /^[MIDFRmidfr]\d+$/) {
                                    $malformed = 1;
                                    last;
                                    }
                                }

                            if ($malformed) {
                                $self->message($line_number, 'E', "invalid reserved attribute format", "$tag: $value");
                                $valid_value = 0;
                                }
                            }

                        elsif ($tag eq 'Derives_from') {
                            # Don't do anything
                            }

                        elsif ($tag eq 'Note') {
                            # Don't do anything
                            }

                        elsif ($tag eq 'Dbxref') {
                            if ($value !~ /^[^:]+:.+$/) {
                                $self->message($line_number, 'E', "invalid reserved attribute format", "$tag: $value");
                                $valid_value = 0;
                                }
                            }

                        elsif ($tag eq 'Ontology_term') {
                            if ($value !~ /^[^:]+:.+$/) {
                                $self->message($line_number, 'E', "invalid reserved attribute format", "$tag: $value");
                                $valid_value = 0;
                                }
                            }

                        elsif ($tag eq 'Indexed') {
                            if ($value !~ /^(0|1)$/) {
                                $self->message($line_number, 'E', "invalid reserved attribute format", "$tag: $value");
                                $valid_value = 0;
                                }
                            }

                        else {
                            $self->message($line_number, 'E', "unrecognized first-uppercase (reserved) tag", "tag: $tag");
                            $valid_value = 0;
                            }

                        # Store value in attributes hash
                        push(@{$feature_attributes{$tag}}, $value);

                        # Store value in valid attributes hash if valid
                        push(@{$valid_feature_attributes{$tag}}, $value) if $valid_value;

                        # Processing of values separated by comma ends here
                        }

                    # Processing of first-uppercase tags ends here
                    }

                # Attribute processing loop ends here
                }

            # Attribute checking ends here
            }

        # Check if we have only one ID (this is an implied requirement)
        # If there is only one, record it
        my $id;
        if (exists $feature_attributes{ID}) {
            if (@{$feature_attributes{ID}} > 1) {
                $self->message($line_number, 'E', "multiple id attribute values", "ID");
                }
            else {
                $id = $feature_attributes{ID}->[0];
                }
            }

        # Check if we have only one Name (this is an implied requirement)
        # (Not used, no need to record)
        if (exists $feature_attributes{Name}) {
            if (@{$feature_attributes{Name}} > 1) {
                $self->message($line_number, 'E', "multiple attribute values", "Name");
                }
            }

        # Construct signature to distinguish multi-feature features
        # my $cleaned_attributes = $attributes;
        # $cleaned_attributes =~ s/Target[^;]+//;
        my $copy_of_attributes = $attributes;
        my $target_id;
        if ($copy_of_attributes =~ s/Target=(\S+)[^;]*//) {
            $target_id = $1;
            }

        my $multi_feature_digest = Digest::SHA1::sha1_hex(join(":", $seqid, $source, $type, $strand, $target_id, $copy_of_attributes));

        # Prepare line type and parsed_data
        $line_type = 'feature';
        @parsed_data = ($source, $type, $id, $multi_feature_digest);
        %additional_information = ( # Capture parent and derives_from information
                                    Parent       => $valid_feature_attributes{Parent} ? $valid_feature_attributes{Parent} : [],
                                    Derives_from => $valid_feature_attributes{Derives_from} ? $valid_feature_attributes{Derives_from} : [],
                                    );

        # End of processing features
        }

   # This information is returned to the load analysis db sub
   return ($line_type, \@parsed_data, \%additional_information);
   }

=head3 validate_unique_ids

 Function  : Goes through the feature table and validates unique ids
 Arguments : None
 Returns   : 1
 Notes     : Stores results in the database (feature.unique_id)

=cut

sub validate_unique_ids {
    my ($self) = @_;

    my $dbh = $self->dbh;

    my $table_id = $self->table_id;

    $self->log("Validating unique ids ...");
    $self->log;

    # Stop parse if max count reached
    if ($self->stop_parse) {
        return 1;
        }

    # Drop indexes
    $self->_manage_indexes("drop", qw[idx_feature_unique_id]);

    $self->log("Selecting ids and counts ...");
    my $id_count_sth = $dbh->prepare(qq[SELECT id as id, count(*) as id_count FROM ${table_id}feature WHERE id IS NOT NULL GROUP BY id]);
    $id_count_sth->execute;
    $self->log_ok;

    # Prepare statements
    my $get_digests_sth    = $dbh->prepare(qq[SELECT distinct digest FROM ${table_id}feature WHERE id=?]);

    my $mark_multiples_sth = $dbh->prepare(qq[UPDATE ${table_id}feature SET unique_id='N' WHERE id=?]);
    my $mark_uniques_sth   = $dbh->prepare(qq[UPDATE ${table_id}feature SET unique_id='Y' WHERE id=?]);

    my $counter = 0;

    $self->log("Going through ids ...");
    $self->log;

    while (my ($id, $id_count) = $id_count_sth->fetchrow_array) {
        if (${counter}%$self->config("line_number_chunk") == 1) {
            $self->log("processed $counter ids");
            }

        # Stop parse if max count reached
        if ($self->stop_parse) {
            last;
            }

        # Count ids
        $counter++;

        if ($id_count > 1) {
            # If id is not unique, check if the digests are same
            $get_digests_sth->execute($id);
            my $digest_count;
            while (my ($digest) = $get_digests_sth->fetchrow_array) {
                $digest_count++;
                }
            if ($digest_count == 0 or $digest_count > 1) { # There has to be a target for multi features
                $mark_multiples_sth->execute($id);
                $self->message_count($self->message_count + 1);
                }
            else {
                $mark_uniques_sth->execute($id);
                }
            }
        else {
            $mark_uniques_sth->execute($id);
            }
        }
    $self->log_ok;

    # Create indexes
    $self->_manage_indexes("create", qw[idx_feature_unique_id]);

    $self->log("Unique id validation complete, processed $counter ids");
    $self->log_ok;

    return 1;
    }

=head3 load_ontology

 Function  : Loads all ontology files
 Arguments : None
 Returns   : 1
 Notes     :

=cut

sub load_ontology {
    my ($self) = @_;

    $self->log("Processing/loading ontology(s) ...");
    $self->log;

    # Don't stop parse even if max count reached

    # Retrieve stored ontology files that (i) can be loaded and (ii) are to be loaded
    my $ref_ontology_files = $self->ontology_files;

    # Check whether we have at least one ontology file
    if (keys %$ref_ontology_files == 0) {
        $self->message(0, 'E', "no valid ontology file is available, will skip type checking");
        $self->log("No valid ontology file is available, will skip type checking");
        }

    # Load all retrieved ontology files
    foreach my $retrieved_ontology_file (values %$ref_ontology_files) {
        $self->_load_ontology_file($retrieved_ontology_file);
        }

    $self->log("Processed/loaded ontology(s)");
    $self->log_ok;

    return 1;
    }

=head4 _retrieve_file

 Function  : Resolves a file naming scheme and retrieves it
 Arguments : $file
 Returns   : $retrieved_file | undef
 Notes     : This is a private method

=cut

sub _retrieve_file {
    my ($self, $file) = @_;

    my $temp_dir = $self->config("temp_dir");

    my $max_ontology_download_size = $self->config("max_ontology_download_size");
    my $download_agent_timeout_sec = $self->config("download_agent_timeout_sec");

    $self->log("_retrieve_file: Retrieving file: $file ...");

    my $retrieved_file;

    if ($file =~ /^http:/ or
        $file =~ /^ftp:/  or
        $file =~ /^file:/    ) {

        my $ua = LWP::UserAgent->new;
        $ua->timeout($download_agent_timeout_sec);
        $ua->max_size($max_ontology_download_size);

        my $request = HTTP::Request->new(GET => $file);
        my $response = $ua->request($request);

        # Check for errors
        my $error;

        if ($response->is_error) {
            $error = $response->status_line;
            }

        if ($response->header("Client-Aborted")) {
            $error = "Allowed ontology file size exceeded!";
            } 

        if (!$error) {
            my ($temp_fh, $temp_file) = File::Temp::tempfile("validate_gff3_XXXXX",
                                                             DIR     => $temp_dir,
                                                             SUFFIX  => '.temp',
                                                             CLEANUP => 1);
            print $temp_fh $response->content;
            close $temp_fh;
            $retrieved_file = $temp_file;
            }
        else {
            $self->message(0, 'E', "cannot retrieve ontology file", "an error occured during retrieval, $file, $error");
            $self->log("_retrieve_file: Cannot retrieve file (an error occured during retrieval): $file, $error");
            }
        }

    elsif ($file =~ /^[^:]+:/) {
        $self->message(0, 'E', "cannot retrieve ontology file", "unknown protocol, $file");
        $self->log("_retrieve_file: Cannot retrieve file (unknown protocol): $file");
        }

    else {
        if (-e $file) {
            $retrieved_file = $file;
            }
        else {
            $self->message(0, 'E', "cannot retrieve ontology file", "local file does not exist, $file");          
            $self->log("_retrieve_file: Cannot retrieve file (local file does not exist): $file");
            }
        }

    $self->log("_retrieve_file: File ($file) retrieved ($retrieved_file)") if $retrieved_file;

    $self->log_ok;

    return $retrieved_file ? $retrieved_file : undef;
    }

=head4 _load_ontology_file

 Function  : Loads and stores an ontology file
 Arguments : $ontology_file
 Returns   : 1
 Notes     : This is a private method

=cut

sub _load_ontology_file {
    my ($self, $ontology_file) = @_;

    $self->log("Loading ontology file ($ontology_file) ...");

    my $parser = new GO::Parser({handler => 'obj', use_cache => 0});

    $parser->parse($ontology_file);
    my $graph = $parser->handler->graph;

    my $existing_graph = $self->graph();

    if ($existing_graph) {
        $self->log("Merging existing graph ...");
        $graph->merge($existing_graph);
        $self->log_ok;
        }

    $self->graph($graph);

    # Get all terms
    my @terms = @{$graph->get_all_nodes};

    # Prepare list of ontology terms
    my %terms_by_both = map { $_->acc  => 1, $_->name  => 1 } @terms;

    $self->terms_by_both(\%terms_by_both);

    # Prepare list of parents
    # - Parents are prepared in two groups:
    #   - parents as provided by the GO:Parser graph (this only traverses up the graph).
    #   - for each term (a), find the part of parents (A), any term which is_a A, is allowed to be a parnt to the term (a).
     
    my %parents_of_by_both;

    my %top_level_terms = (
        'Sequence_Ontology'         => 1,
        'located_sequence_feature'  => 1,
        'junction'                  => 1,
        'region'                    => 1,
        'sequence_variant'          => 1, 
        );    
    
    foreach my $term (@terms) {
        my $part_of_parents = $self->_get_recursive_parent_terms_by_types($graph, $term, "part_of", "is_a", "member_of");

        my @gff_parents;
        
        foreach my $part_of_parent (@$part_of_parents) {
            my $is_a_children = $graph->get_recursive_child_terms_by_type($part_of_parent->acc, "is_a");

            my $already_a_child = List::Util::first { $_->name eq $term->name } @$is_a_children if $is_a_children;

            if ($top_level_terms{$part_of_parent->name}) {
                push (@gff_parents, $part_of_parent);
                }
                
            elsif (!@$is_a_children) {
                push (@gff_parents, $part_of_parent);
                }

            elsif (@$is_a_children and !$already_a_child) {
                push (@gff_parents, $part_of_parent, @$is_a_children);
                }

            else {
                }
            }    

        my @parent_accs  = map { $_->acc  => 1 } @gff_parents;
        my @parent_names = map { $_->name => 1 } @gff_parents;

        $parents_of_by_both{$term->acc}{child_of_by_acc}   = { @parent_accs  };
        $parents_of_by_both{$term->acc}{child_of_by_name}  = { @parent_names };

        $parents_of_by_both{$term->name}{child_of_by_acc}  = { @parent_accs  };
        $parents_of_by_both{$term->name}{child_of_by_name} = { @parent_names };
        }

    $self->parents_of_by_both(\%parents_of_by_both);
# print Dumper(\%parents_of_by_both);

    # Prepare list of derives_from
    my %derives_from_by_both;

    foreach my $term (@terms) {
        my $gff_parents = $graph->get_parent_terms_by_type($term->acc, "derives_from"); # Not recursive

        my @parent_accs  = map { $_->acc  => 1 } @$gff_parents;
        my @parent_names = map { $_->name => 1 } @$gff_parents;

        $derives_from_by_both{$term->acc}{by_acc}    = { @parent_accs  };
        $derives_from_by_both{$term->acc}{by_name}   = { @parent_names };

        $derives_from_by_both{$term->name}{by_acc}   = { @parent_accs  };
        $derives_from_by_both{$term->name}{by_name}  = { @parent_names };
        }

    $self->derives_from_by_both(\%derives_from_by_both);

    $self->log("Loaded ontology file ($ontology_file)");
    $self->log_ok;

    return 1;
    }

=head3 _get_recursive_parent_terms_by_types

 Function  : Retrieves all parent terms by multiple types
 Arguments : $graph, $term, @types
 Returns   : $array_ref
 Notes     : This is a private method.

=cut

sub _get_recursive_parent_terms_by_types {
    my ($self, $graph, $term, @types) = @_;

    my @next_parents = ();
    my @all_parents = ();
    
    foreach my $type (@types) {
        my $parents_ref = $graph->get_parent_terms_by_type($term->acc, $type);
        push @next_parents, @$parents_ref if @$parents_ref;
        }
    
    $self->_get_recursive_parent_terms_by_types_r($graph, \@types, \@next_parents, \@all_parents);
    
    my %all_parents = map { $_->name => $_ } @all_parents;
    @all_parents = values %all_parents;
    
    return \@all_parents;
    }

=head3 _get_recursive_parent_terms_by_types_r

 Function  : Retrieves all parent terms by multiple types (recursive component)
 Arguments : $graph, \@types, \@next_parents, \@all_parents
 Returns   : 1 (\@next_parents & \@all_parents are modified)
 Notes     : This is a private method.

=cut

sub _get_recursive_parent_terms_by_types_r {
    my ($self, $graph, $types_ref, $next_parents_ref, $all_parents_ref) = @_;

    my $next_parent = pop @$next_parents_ref;

    if ($next_parent) {
        push @$all_parents_ref, $next_parent;
        foreach my $type (@$types_ref) {
            my $parents_ref = $graph->get_parent_terms_by_type($next_parent->acc, $type);
            push @$next_parents_ref, @$parents_ref if @$parents_ref;
            push @$all_parents_ref, @$parents_ref if @$parents_ref;            
            }
        }
    
    if (@$next_parents_ref) {
        $self->_get_recursive_parent_terms_by_types_r($graph, $types_ref, $next_parents_ref, $all_parents_ref);
        }
    
    return 1;
    }

=head3 validate_ontology_terms

 Function  : Goes through the feature table and validates types
 Arguments : None
 Returns   : 1
 Notes     : Stores results in the database (feature.valid_type)

=cut

sub validate_ontology_terms {
    my ($self, $ontology_file) = @_;

    my $dbh = $self->dbh;

    my $table_id = $self->table_id;

    $self->log("Validating ontology terms ...");
    $self->log;

    # Stop parse if max count reached
    if ($self->stop_parse) {
        return 1;
        }

    # Get graph, if none, skip this check
    my $graph = $self->graph;
    if (!$graph) {
        $self->log("No ontology loaded, skipping ontology term validation, please check error report");
        $self->log_ok;
        return 1;
        }

    # Drop indexes
    $self->_manage_indexes("drop", qw[idx_feature_valid_type]);

    # Retrieve hashes of terms
    my $terms_by_both = $self->terms_by_both;

    # Prepare mark statements;
    my $mark_valid_sth   = $dbh->prepare(qq[UPDATE ${table_id}feature SET valid_type='Y' WHERE type=?]);
    # my $mark_invalid_sth = $dbh->prepare(qq[UPDATE ${table_id}feature SET valid_type='N' WHERE type=?]);

    # Run through all feature table
    $self->log("Selecting distinct types ...");
    my $types_sth = $dbh->prepare(qq[SELECT distinct type FROM ${table_id}feature WHERE type IS NOT NULL]);
    $types_sth->execute;
    $self->log_ok;

    $self->log("Going through types ...");
    $self->log;

    # SQLite does not allow accessing database concurrently.
    # Read all into memory first and go through it later.
    # *** If this creates large memory consumption, cache it into a temp file ***
    my @types;
    while (my ($type) = $types_sth->fetchrow_array) {
        push @types, $type;
        }
    
    foreach my $type (@types) {    
        my $mark_sth;

        # Stop parse if max count reached
        if ($self->stop_parse) {
            last;
            }

        if ($terms_by_both->{$type}) {
            $mark_valid_sth->execute($type);
            }
        else {
            # $mark_invalid_sth->execute($type);
            my $row_count = $dbh->do(qq[UPDATE ${table_id}feature SET valid_type='N' WHERE type=] . $dbh->quote($type));
            $self->message_count($self->message_count + $row_count);
            }

        $self->log("Processed type ($type)");
        }
    $self->log_ok;

    # Create indexes
    $self->_manage_indexes("create", qw[idx_feature_valid_type]);

    $self->log("Ontology term validation complete");
    $self->log_ok;

    return 1;
    }

=head3 validate_parentage

 Function  : Goes through parent table and validates relationships
 Arguments : None
 Returns   : 1
 Notes     :

=cut

sub validate_parentage {
    my ($self) = @_;

    my $dbh = $self->dbh;

    my $table_id = $self->table_id;

    $self->log("Validating parentage ...");
    $self->log;

    # Stop parse if max count reached
    if ($self->stop_parse) {
        return 1;
        }

    # Drop indexes
    $self->_manage_indexes("drop", qw[idx_parent_valid_link]);

    $self->log("Selecting parent assignments ...");
    my $relationships_sth = $dbh->prepare(qq[SELECT parent.parent_id, parent.line_number, parent.parent
                                             FROM ${table_id}parent parent
                                             LEFT JOIN ${table_id}feature parent_details ON (parent_details.id = parent.parent)
                                             LEFT JOIN ${table_id}feature child_details  ON (child_details.line_number = parent.line_number)
                                             WHERE
                                             (parent_details.valid_type = 'Y' OR parent_details.valid_type IS NULL) AND
                                             (parent_details.unique_id  = 'Y' OR parent_details.unique_id  IS NULL) AND
                                             child_details.valid_type   = 'Y'
                                             ]);

    $relationships_sth->execute;
    $self->log_ok;

    my $mark_sth = $dbh->prepare(qq[UPDATE ${table_id}parent SET valid_link=? WHERE parent_id=?]);

    my $counter = 0;

    $self->log("Going through parent assignments ...");

    # SQLite does not allow accessing database concurrently.
    # Read all into memory first and go through it later.
    # *** If this creates large memory consumption, cache it into a temp file ***
    my @data;
    while (my (@ary) = $relationships_sth->fetchrow_array) {
        push @data, \@ary;
        }

    foreach my $data_ref (@data) {
        my ($parent_id, $line_number, $parent_in_file) = @$data_ref;
        if (${counter}%$self->config("line_number_chunk") == 1) {
            $self->log("processed $counter parent assignments");
            }

        # Stop parse if max count reached
        if ($self->stop_parse) {
            last;
            }

        # Count ids
        $counter++;

        my $feature = $self->_get_valid_feature_by_line_number($line_number);
        my $parent  = $self->_get_valid_feature_by_id($parent_in_file);

        if (!$parent) {
            $self->message($line_number, 'E', "non-unique or non-existing parent", "parent_id: $parent_in_file");

            $mark_sth->execute('N', $parent_id);

            next;
            }

        $feature->{parents} = [$parent];

        my $parentage_ref = { feature       => $feature,
                              invalid_link  => undef,
                              error_type    => undef,
                              };

        $self->_build_recursive_parentage($parentage_ref, [$feature]);

        if ($parentage_ref->{invalid_link}) {
            $self->message($line_number, 'E', @{$parentage_ref->{error_type}});

            $mark_sth->execute('N', $parent_id);
            }

        else {
            $mark_sth->execute('Y', $parent_id);
            }
        }
    $self->log_ok;

    # Create indexes
    $self->_manage_indexes("create", qw[idx_parent_valid_link]);

    $self->log("Parentage validation complete, processed $counter parent assignments");
    $self->log_ok;

    return 1;
    }

=head4 _build_recursive_parentage

 Function  : Recursive method for identfying all parents and their validity
 Arguments : $parentage_ref, $unprocessed_features_ref
 Returns   : 1
 Notes     : This is a private method

=cut

sub _build_recursive_parentage {
    my ($self, $parentage_ref, $unprocessed_features_ref) = @_;

    my @unprocessed_features_ref = @$unprocessed_features_ref; # Make a copy

    $unprocessed_features_ref = []; # Empty

    my $child_id = $parentage_ref->{feature}->{id};
    
    # Retrieve hashes of parents_of
    my $parents_of_by_both = $self->parents_of_by_both;
# print Dumper($parents_of_by_both);
    BUILD:
    foreach my $unprocessed_feature (@unprocessed_features_ref) {
        my @parent_ids = $self->_get_parents($unprocessed_feature);

        my @parents;
        
        # Skip, if a parent is an invalid feature (non-unique, non-existing)
        foreach my $parent_id (@parent_ids) {
            my $parent_feature = $self->_get_valid_feature_by_id($parent_id);
            if (!defined $parent_feature) {
                $parentage_ref->{invalid_link} = 1;
                $parentage_ref->{error_type}   = [qq[non-unique or non-existing grand-parent term], qq[invalid parent: $parent_id]]; # goes to $self->message
                $unprocessed_features_ref = []; # Empty
                last BUILD;
                }
            push @parents, $parent_feature;
            }

        # Skip, if there is circular reference
        foreach my $parent (@parents) {
            if ($parent->{id} eq $child_id) {
                $parentage_ref->{invalid_link} = 1;
                $parentage_ref->{error_type}   = [qq[circular reference - check all parents], 
                                                  qq[at line ] . $parent->{line_number}]; # goes to $self->message
                $unprocessed_features_ref = []; # Empty
                last BUILD;
                }
            }    

        # Skip, if type pair cannot have a part-of relationship
        my $child_type = $unprocessed_feature->{type};
        foreach my $parent (@parents) {
            my $parent_type = $parent->{type};
            unless ($parents_of_by_both->{$child_type}->{child_of_by_acc}->{$parent_type} or
                    $parents_of_by_both->{$child_type}->{child_of_by_name}->{$parent_type}) {
                    $parentage_ref->{invalid_link} = 1;
                    $parentage_ref->{error_type}   = [qq[invalid type pair - check all parents], 
                                                      qq[at line ] . $parent->{line_number} . qq[; $child_type to $parent_type]]; # goes to $self->message
                    $unprocessed_features_ref = []; # Empty
                    last BUILD;
                    }
            }

        # Parents are valid, schedule them for further analysis
        $unprocessed_feature->{parents} = \@parents;
        if (@parents > 0) { push (@$unprocessed_features_ref, @parents); }
        }

    if (@$unprocessed_features_ref) { $self->_build_recursive_parentage($parentage_ref, $unprocessed_features_ref); }

    return 1;
    }

=head4 _get_parents

 Function  : Retrieves parents of a given feature
 Arguments : $feature (as a hashref)
 Returns   : @parents
 Notes     : This is a private method

=cut

sub _get_parents {
    my ($self, $feature) = @_;

    my $line_number =  $feature->{line_number};

    my $sth = $self->get_sth('get_parents');

    $sth->execute($line_number);

    my @parent_ids;

    while (my ($parent_id) = $sth->fetchrow_array) {
        push (@parent_ids, $parent_id);
        }

    return (@parent_ids);
    }

=head3 validate_derives_from

 Function  : Goes through derives_from table and
             validates relationships (only one level)
 Arguments : None
 Returns   : 1
 Notes     :

=cut

sub validate_derives_from {
    my ($self) = @_;

    my $dbh = $self->dbh;

    my $table_id = $self->table_id;

    $self->log("Validating derives_from ...");
    $self->log;

    # Stop parse if max count reached
    if ($self->stop_parse) {
        return 1;
        }

    # Drop indexes
    $self->_manage_indexes("drop", qw[idx_derives_from_valid_link]);

    # Retrieve hashes of derives_from
    my $derives_from_by_both = $self->derives_from_by_both;

    $self->log("Selecting derives_from assignments ...");
    my $relationships_sth = $dbh->prepare(qq[SELECT parent.derives_from_id, parent.line_number, parent.derives_from
                                             FROM ${table_id}derives_from parent
                                             LEFT JOIN ${table_id}feature parent_details ON (parent_details.id = parent.derives_from)
                                             LEFT JOIN ${table_id}feature child_details  ON (child_details.line_number = parent.line_number)
                                             WHERE
                                             (parent_details.valid_type = 'Y' OR parent_details.valid_type IS NULL) AND
                                             (parent_details.unique_id  = 'Y' OR parent_details.unique_id  IS NULL) AND
                                             child_details.valid_type   = 'Y'
                                             ]);

    $relationships_sth->execute;
    $self->log_ok;

    my $mark_sth = $dbh->prepare(qq[UPDATE ${table_id}derives_from SET valid_link=? WHERE derives_from_id=?]);

    my $counter = 0;

    $self->log("Going through derives_from assignments ...");
    while (my ($derives_from_id, $line_number, $derives_from) = $relationships_sth->fetchrow_array) {
        if (${counter}%$self->config("line_number_chunk") == 1) {
            $self->log("processed $counter derives_from assignments");
            }

        # Stop parse if max count reached
        if ($self->stop_parse) {
            last;
            }

        # Count ids
        $counter++;

        my $child = $self->_get_valid_feature_by_line_number($line_number);
        my $parent  = $self->_get_valid_feature_by_id($derives_from);

        if (!$parent) {
            $self->message($line_number, 'E', "non-unique or non-existing (derives_from) parent", "parent: $parent");
            $mark_sth->execute('N', $derives_from_id);

            next;
            }

        my $child_type = $child->{type};
        my $parent_type = $parent->{type};

        $self->message($line_number, 'W', "the validity of derives from relationship is not checked by the validator", "$child_type to $parent_type");
#
#        *** Temporarily disable checking validity of derives_from relationship ***
#        
#        if ($derives_from_by_both->{$child_type}->{by_acc}->{$parent_type} or
#            $derives_from_by_both->{$child_type}->{by_name}->{$parent_type}) {
#                $mark_sth->execute('Y', $derives_from_id);
#                }
#        else {
#            $self->message($line_number, 'E', qq[invalid derives_from relationship], qq[terms: $child_type, $parent_type]);
#            $mark_sth->execute('N', $derives_from_id);
#                }

        }

    $self->log_ok;

    # Create indexes
    $self->_manage_indexes("create", qw[idx_derives_from_valid_link]);

    $self->log("Parentage validation complete, processed $counter parent assignments");
    $self->log_ok;

    return 1;
    }

=head3 dump_report

 Function  : Generates a detailed error/warning report
 Arguments : None
 Returns   : 0|1
 Notes     :

=cut

sub dump_report {
    my ($self) = @_;

    my $gff3_file = $self->gff3_file;
    my $report_file = $self->report_file;
    my $dbh = $self->dbh;

    my $table_id = $self->table_id;

    my $complete_parse = $self->complete_parse;
    
    $self->log("Generating report ...");
    $self->log;

    my ($database_info) = $dbh->{Name} =~ /dbname=(.*)/;
    # my $description = qq[gff3_file: $gff3_file; ontology_file(s): ] . join(",", sort keys %{$self->ontology_files}) . qq[; database: ] . $database_info;
    my @ontology_files;
    foreach my $ontology_file (sort keys %{$self->ontology_files}) {
        if ($ontology_file =~ /file:\/\//) {
            $ontology_file =~ s/\/+$//; 
            my ($ontology_file_name) = $ontology_file =~ /([^\/]+)$/; 
            $ontology_file = "[DIR]/$ontology_file_name";
            }
         push @ontology_files, $ontology_file;
         }   
    my $description = qq[ontology_file(s): ] . join(",", @ontology_files);
    my $time_stamp = qq[generated: ] . $time{"dd-Mon-yy hh:mm:ss"};

    # Count errors
    my $error_count = 0;
    my @statements = (qq[SELECT count(*) FROM ${table_id}message WHERE type = 'E'],
                      qq[SELECT count(*) FROM ${table_id}feature WHERE valid_type = 'N'],
                      qq[SELECT count(*) FROM ${table_id}feature WHERE unique_id = 'N'],
                      );
    foreach my $statement (@statements) {
        my $sth = $dbh->prepare($statement);
        $sth->execute;

        my ($count) = $sth->fetchrow_array;
        $error_count += $count;
        }
    $self->error_count($error_count);  

    # Count warnings
    my $warning_count = 0;
    @statements = (qq[SELECT count(*) FROM ${table_id}message WHERE type = 'W'],
                      );
    foreach my $statement (@statements) {
        my $sth = $dbh->prepare($statement);
        $sth->execute;

        my ($count) = $sth->fetchrow_array;
        $warning_count += $count;
        }
    $self->warning_count($warning_count);  

    # Open report file
    open (REPORT_FILE, ">$report_file") or croak("Cannot write report file ($report_file):$!");

    # Initialize report file
    print REPORT_FILE "# GFF3 File Validation Report\n";
    print REPORT_FILE "# $description\n";
    print REPORT_FILE "# $time_stamp\n";
    print REPORT_FILE "\n";

    # Print whether there are any errors or not
    my $return_value;
    if (!$self->error_count && !$self->warning_count) {
        print REPORT_FILE "###############################################################################\n";
        print REPORT_FILE "# THIS FILE HAS BEEN VALIDATED, NO ERRORS OR WARNINGS HAVE BEEN ISSUED!       #\n";
        print REPORT_FILE "###############################################################################\n";
        $return_value = 1;
        }

    elsif (!$self->error_count && $self->warning_count) {
        print REPORT_FILE "###############################################################################\n";
        print REPORT_FILE "# THIS FILE HAS BEEN VALIDATED, NO ERRORS HAVE BEEN ISSUED!                   #\n";
        print REPORT_FILE "# (SOME WARNINGS HAVE BEEN ISSUED, PLEASE REVIEW REPORT)                      #\n";
        print REPORT_FILE "###############################################################################\n";
        $return_value = 1;
        }

    elsif ($self->error_count && !$self->warning_count) {
        print REPORT_FILE "###############################################################################\n";
        print REPORT_FILE "# THIS FILE HAS NOT BEEN VALIDATED, IT CONTAINS ERRORS, PLEASE REVIEW REPORT! #\n";
        print REPORT_FILE "# (NO WARNINGS HAVE BEEN ISSUED FOR THIS FILE)                                #\n";
        print REPORT_FILE "###############################################################################\n";
        $return_value = 0;
        }

    elsif ($self->error_count && $self->warning_count) {
        print REPORT_FILE "###############################################################################\n";
        print REPORT_FILE "# THIS FILE HAS NOT BEEN VALIDATED, IT CONTAINS ERRORS, PLEASE REVIEW REPORT! #\n";
        print REPORT_FILE "# (SOME WARNINGS HAVE BEEN ISSUED AS WELL, PLEASE REVIEW REPORT)              #\n";
        print REPORT_FILE "###############################################################################\n";
        $return_value = 0;
        }
    print REPORT_FILE "\n";

    # Print if file was parsed completely
    if ($complete_parse) {
        print REPORT_FILE "###############################################################################\n";
        print REPORT_FILE "# THIS FILE HAS BEEN PROCESSED ENTIRELY AND ALL ERRORS/WARNINGS ARE REPORTED! #\n";
        print REPORT_FILE "###############################################################################\n";
        }

    else {
        my $max_messages_formatted = sprintf("% 6s", $self->max_messages);
        print REPORT_FILE "###############################################################################\n";
        print REPORT_FILE "# VALIDATION OF THIS FILE HAS BEEN TERMINATED AFTER $max_messages_formatted ERRORS,            #\n";
        print REPORT_FILE "# PER SPECIFIED PARAMETERS! PLEASE CHANGE ACCORDINGLY AND RESUBMIT!           #\n";
        print REPORT_FILE "###############################################################################\n";
        }
    print REPORT_FILE "\n";
        
    # Print out first 10 lines of the GFF3 file
    my $gff3_file_start;
    my $line_count = 0;
    open (FILE_START, "<$gff3_file") or croak("Cannot open GFF3 file ($gff3_file): $!");
    foreach my $i (1..10) {
        $line_count++;
        if (my $line = <FILE_START>) {
            $line =~ s/(.{30,40}[\s\,\;])/$1\n/g;
            chomp $line;
            my $position = 0;
            foreach my $l (split("\n", $line)) {
                $gff3_file_start .= "[line $line_count]> $l\n";
                }
            }
        } 
    close FILE_START;

    print REPORT_FILE "# First 10 lines of the analyzed GFF3 file follows:\n";
    print REPORT_FILE "#\n";
    print REPORT_FILE $gff3_file_start;
    print REPORT_FILE "# ...\n";
    print REPORT_FILE "\n";

    # Dump errors by line number
    my $statement = qq[SELECT line_number as line_number, CONCAT("[ERROR]   ", message)     as message, details                     as details FROM ${table_id}message WHERE type = 'E'
                       UNION
                       SELECT line_number as line_number, CONCAT("[WARNING] ", message)     as message, details                     as details FROM ${table_id}message WHERE type = 'W'
                       UNION
                       SELECT line_number as line_number, "[ERROR]   invalid type"  as message, CONCAT("type: ", type) as details FROM ${table_id}feature WHERE valid_type = 'N'
                       UNION
                       SELECT line_number as line_number, "[ERROR]   non-unique id" as message, CONCAT("id: ", id)     as details FROM ${table_id}feature WHERE unique_id = 'N'
                       ORDER BY line_number
                       ];
    
    # SQLite does not support CONCAT function (accepts || operator).
    # Replace CONCAT for SQLite version
    if ($self->db_type eq 'sqlite') {
        $statement =~ s/CONCAT\(([^\)]+), ([^\)]+)\)/$1 || $2/g;
        }

    my $sth = $dbh->prepare($statement);
    $sth->execute;

    # Print header
    print REPORT_FILE sprintf("%-12s", "Line Number") . " Error/Warning\n";
    print REPORT_FILE sprintf("%-12s", "-----------") . " -------------\n";

    # Print out error/warnings
    while (my ($line_number, $message, $details) = $sth->fetchrow_array) {
        my $details_section = $details ? "($details)" : "";
        my $line = "$message $details_section";
        $line =~ s/(.{70,90}[\s\,])/$1\n/g;
        chomp $line;
        my $position = 0;
        foreach my $l (split("\n", $line)) {
            $position++;
            if ($position == 1) {
                print REPORT_FILE sprintf("%-12s", $line_number) . " $l\n";
                }
            else {
                print REPORT_FILE sprintf("%-12s", "") . " $l\n";
                }
            }
        }

    print REPORT_FILE "\n";
    print REPORT_FILE "# [END]\n";

    close REPORT_FILE or croak("Cannot close report file ($report_file): $!");

    $self->log("Report generated");
    $self->log_ok;

    return $return_value;
    }

=head2 Utility Methods

=head3 _prepare_sths

 Function  : Prepares and stores statement handles
 Arguments : None
 Returns   : 1
 Notes     : This is a private method

=cut

sub _prepare_sths {
	my ($self) = @_;

    my $dbh = $self->dbh;

    my $table_id = $self->table_id;

    my %statements = (
        insert_message                      => qq[INSERT INTO ${table_id}message
                                                 (line_number, type, message, details)
                                                 VALUES (?, ?, ?, ?)],
        get_parents                         => qq[SELECT parent FROM ${table_id}parent WHERE line_number = ?],
        get_valid_feature_by_id             => qq[SELECT line_number, type FROM ${table_id}feature
                                                 WHERE id = ? AND valid_type = 'Y' AND unique_id = 'Y'],
        get_valid_feature_by_line_number    => qq[SELECT type, id FROM ${table_id}feature
                                                 WHERE line_number = ? AND valid_type = 'Y' 
                                                 AND (id IS NULL OR (id IS NOT NULL AND unique_id = 'Y'))], 
        get_byte_offset                     => qq[SELECT byte_offset FROM ${table_id}byte_offset WHERE line_number = ?],
        );    
    
    my %sths;
    foreach my $statement_key (keys %statements) {
        my $statement = $statements{$statement_key};
        $sths{$statement_key} = $dbh->prepare($statement);
        }
    
    # Store sths
    $self->{statements} = \%statements;

    # Store sths
    $self->{sths} = \%sths;

    return 1;
	}

=head3 message

 Function  : Records a message
 Arguments : ($line_number, $type, $message, $details)
 Returns   : 1
 Notes     :

=cut

sub message {
	my ($self, $line_number, $type, $message, $details) = @_;

    $type = uc($type);
    if ($type !~ /^(E|W)$/) {
        croak("Invalid message type ($type)!");
        }

    $self->message_count($self->message_count + 1) if $type eq 'E';
    
    my $log_message = $details ? qq[$message ($details)]
                               : qq[$message];

    $self->log("[line:$line_number] $type: $log_message");

    my $sth = $self->get_sth("insert_message");

    $sth->execute($line_number, $type, $message, $details);

    return 1;
	}

=head3 _manage_indexes

 Function  : Creates and drops indexes
 Arguments : $action, @indexes
 Returns   : 1
 Notes     : This is an internal method

=cut

sub _manage_indexes {
	my ($self, $action, @indexes) = @_;

    my $dbh = $self->dbh;

    my $db_type = $self->db_type;
    
    my $table_id = $self->table_id;

    my %indexes = ( # index_name                    #table              # columns
                    idx_byte_offset_line_number     => ["${table_id}byte_offset",  "line_number"],
                    idx_byte_offset_byte_offset     => ["${table_id}byte_offset",  "byte_offset"],

                    idx_feature_line_number         => ["${table_id}feature",      "line_number"],
                    idx_feature_source              => ["${table_id}feature",      "source(10)"],
                    idx_feature_type                => ["${table_id}feature",      "type(10)"],
                    idx_feature_id                  => ["${table_id}feature",      "id(50)"],
                    idx_feature_digest              => ["${table_id}feature",      "digest(10)"],
                    idx_feature_valid_source        => ["${table_id}feature",      "valid_source"],
                    idx_feature_valid_type          => ["${table_id}feature",      "valid_type"],
                    idx_feature_unique_id           => ["${table_id}feature",      "unique_id"],

                    idx_directive_line_number       => ["${table_id}directive",    "line_number"],
                    idx_directive_directive         => ["${table_id}directive",    "directive"],

                    idx_parent_line_number          => ["${table_id}parent",       "line_number"],
                    idx_parent_parent               => ["${table_id}parent",       "parent(50)"],
                    idx_parent_valid_link           => ["${table_id}parent",       "valid_link"],

                    idx_derives_from_line_number    => ["${table_id}derives_from", "line_number"],
                    idx_derives_from_derives_from   => ["${table_id}derives_from", "derives_from(50)"],
                    idx_derives_from_valid_link     => ["${table_id}derives_from", "valid_link"],

                    );

    foreach my $index (@indexes) {
        croak("Unknown index ($index)!") unless $indexes{$index};
        }

    foreach my $index (@indexes) {
        my ($table, $columns) = @{$indexes{$index}};

        # SQLite does not support limiting size of column that will be used within the 
        # index. These designations need to be removed
        $columns =~ s/\(\d+\)//g if $db_type eq 'sqlite';
        
        if ($action eq "create") {
            my $statement = qq[CREATE INDEX ${table_id}$index ON $table($columns)];
            $self->log("Creating index: ${table_id}$index ...");
            $dbh->do($statement);
            $self->log_ok;
            }

        elsif ($action eq "drop") {
            my $statement = qq[DROP INDEX ${table_id}$index ON $table];
            $self->log("Dropping index: ${table_id}$index ...");
            $dbh->{RaiseError} = 0;
            $dbh->{PrintError} = 0;
            $dbh->do($statement); # This can fail
            $dbh->{RaiseError} = 1;
            $dbh->{PrintError} = 1;
            $self->log_ok;
            }
        else { croak("Unknown _manage_indexes action ($action)!"); }
        }

    return 1;
	}

=head3 _get_valid_feature_by_id

 Function  : Retrieves a valid feature by id
 Arguments : $id
 Returns   : $hashref | undef
 Notes     : This is a private method

=cut

sub _get_valid_feature_by_id {
    my ($self, $key) = @_;

    my $sth = $self->get_sth('get_valid_feature_by_id');

    $sth->execute($key);

    my ($line_number, $type) = $sth->fetchrow_array;

    my %feature = (line_number => $line_number,
                   type        => $type,
                   id          => $key,
                   );

    return $line_number ? \%feature : undef;
    }

=head3 _get_valid_feature_by_line_number

 Function  : Retrieves a valid feature by line_number
 Arguments : $line_number
 Returns   : $hashref | undef
 Notes     : This is a private method

=cut

sub _get_valid_feature_by_line_number {
    my ($self, $key) = @_;

    my $sth = $self->get_sth('get_valid_feature_by_line_number');

    $sth->execute($key);

    my ($type, $id) = $sth->fetchrow_array;

    my %feature = (line_number => $key,
                   type        => $type,
                   id          => $id,
                   );

    return defined $type ? \%feature : undef;
    }

=head3 log

 Function  : Logs progress
 Arguments : $message
 Returns   : 1
 Notes     :

=cut

sub log {
    my ($self, $message) = @_;

    # Skip logging if no log file present
    if (!$self->log_file) {
        return 1;
        }

    my $time_stamp = '[' . $time{"dd-Mon-yy hh:mm:ss"} . ']';

    $message =~ s/\n+$//;

    my $log_string = $time_stamp . " $message" . "\n";

    # Determine whether to report (write/display) the line based on verbosity and type of message
    my $report_message = 0;
    if ($self->verbose > 2) {
        $report_message = 1;
        }

    elsif ($self->verbose > 1) {
        $report_message = 1 if $message !~ /^\[line:\d+\] /;
        }

    elsif ($self->verbose > 0) {
        $report_message = 1 if $message =~ /^#/;
        }

    else {
        # Don't print it to screen
        }

    # Write to file if applicable
    my $log_file = $self->log_file;
    if ($log_file and $report_message) {
        open (LOG_FILE, ">>$log_file") or croak("Cannot append log file ($log_file)!");
        print LOG_FILE $log_string;
        close LOG_FILE;
        }

    # Write to screen if applicable
    if ($report_message and !$self->silent) {
        print $log_string;
        }

    return 1;
    }

=head3 log_ok

 Function  : Logs a "completed" statement
 Arguments : None
 Returns   : 1
 Notes     :

=cut

sub log_ok {
    my ($self) = @_;

    $self->log("[OK]");
    $self->log;

    return 1;
    }

=head3 get_line

 Function  : Retrieves a line from gff3_file by a line number
 Arguments : $gff3_file, $line_number
 Returns   : $line
 Notes     :

=cut

sub get_line {
    my ($self, $line_number) = @_;

    my $gff3_file = $self->gff3_file;

    croak("A line number (greater than 0) must be specified!") unless $line_number;

    my $sth = $self->get_sth("get_byte_offset");

    my $byte_offset;

    if ($line_number == 1) {
        $byte_offset = 0;
        }

    else {
        $line_number--;

        $sth->execute($line_number);

        ($byte_offset) = $sth->fetchrow_array;
        }

    croak("Invalid line number ($line_number)!") unless defined $byte_offset;

    open (GFF_FILE, "<$gff3_file") or croak("Cannot open gff3 file ($gff3_file): $!");

    seek(GFF_FILE, $byte_offset, 0);

    my $line = <GFF_FILE>;

    chomp $line;

    return $line;
	}

=head1 SEE ALSO

=head1 AUTHOR

Payan Canaran <canaran@cshl.edu>

=head1 VERSION

$Id: Validator.pm,v 1.1 2007/12/03 14:20:23 canaran Exp $

=head1 CREDITS

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2006-2007 Cold Spring Harbor Laboratory

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself. See DISCLAIMER.txt for
disclaimers of warranty.

=cut

1;
